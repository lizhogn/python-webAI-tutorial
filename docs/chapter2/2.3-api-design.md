# 2.3 API è®¾è®¡

## ğŸ“– æ¦‚è¿°

æœ¬ç« å°†å­¦ä¹  RESTful API è®¾è®¡åŸåˆ™ã€API ç‰ˆæœ¬ç®¡ç†ã€é”™è¯¯å¤„ç†ã€æ–‡æ¡£ç”Ÿæˆç­‰ï¼Œå¸®åŠ©æ‚¨è®¾è®¡å‡ºé«˜è´¨é‡ã€æ˜“ç»´æŠ¤çš„ Web APIã€‚

## ğŸ—ï¸ RESTful API è®¾è®¡åŸåˆ™

### REST æ¶æ„é£æ ¼

RESTï¼ˆRepresentational State Transferï¼‰æ˜¯ä¸€ç§è½¯ä»¶æ¶æ„é£æ ¼ï¼Œå¼ºè°ƒï¼š
- **æ— çŠ¶æ€**ï¼šæ¯ä¸ªè¯·æ±‚åŒ…å«æ‰€æœ‰å¿…è¦ä¿¡æ¯
- **ç»Ÿä¸€æ¥å£**ï¼šä½¿ç”¨æ ‡å‡† HTTP æ–¹æ³•
- **èµ„æºå¯¼å‘**ï¼šä»¥èµ„æºä¸ºä¸­å¿ƒè®¾è®¡ API
- **å¯ç¼“å­˜**ï¼šæ”¯æŒç¼“å­˜æœºåˆ¶
- **åˆ†å±‚ç³»ç»Ÿ**ï¼šæ”¯æŒä»£ç†ã€ç½‘å…³ç­‰ä¸­é—´å±‚

### HTTP æ–¹æ³•è¯­ä¹‰

| æ–¹æ³• | è¯­ä¹‰ | å¹‚ç­‰æ€§ | å®‰å…¨æ€§ |
|------|------|--------|--------|
| **GET** | è·å–èµ„æº | âœ… | âœ… |
| **POST** | åˆ›å»ºèµ„æº | âŒ | âŒ |
| **PUT** | æ›´æ–°èµ„æºï¼ˆå®Œæ•´ï¼‰ | âœ… | âŒ |
| **PATCH** | æ›´æ–°èµ„æºï¼ˆéƒ¨åˆ†ï¼‰ | âŒ | âŒ |
| **DELETE** | åˆ é™¤èµ„æº | âœ… | âŒ |

### URL è®¾è®¡è§„èŒƒ

```python
# âœ… å¥½çš„è®¾è®¡
GET    /api/v1/users              # è·å–ç”¨æˆ·åˆ—è¡¨
GET    /api/v1/users/123          # è·å–ç‰¹å®šç”¨æˆ·
POST   /api/v1/users              # åˆ›å»ºç”¨æˆ·
PUT    /api/v1/users/123          # æ›´æ–°ç”¨æˆ·
DELETE /api/v1/users/123          # åˆ é™¤ç”¨æˆ·

# åµŒå¥—èµ„æº
GET    /api/v1/users/123/posts    # è·å–ç”¨æˆ·çš„æ–‡ç« 
POST   /api/v1/users/123/posts    # ä¸ºç”¨æˆ·åˆ›å»ºæ–‡ç« 

# æŸ¥è¯¢å‚æ•°
GET    /api/v1/users?page=1&size=10&sort=name
GET    /api/v1/users?role=admin&active=true

# âŒ ä¸å¥½çš„è®¾è®¡
GET    /api/v1/getUsers
POST   /api/v1/createUser
GET    /api/v1/user?id=123
```

## ğŸ“Š çŠ¶æ€ç å’Œå“åº”æ ¼å¼

### HTTP çŠ¶æ€ç 

```python
from fastapi import HTTPException, status

# æˆåŠŸå“åº”
@app.get("/users/{user_id}")
async def get_user(user_id: int):
    user = get_user_by_id(user_id)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User not found"
        )
    return user

# è‡ªå®šä¹‰çŠ¶æ€ç 
@app.post("/users", status_code=status.HTTP_201_CREATED)
async def create_user(user: UserCreate):
    return create_user_in_db(user)

# æ‰¹é‡æ“ä½œ
@app.post("/users/batch", status_code=status.HTTP_207_MULTI_STATUS)
async def create_users_batch(users: List[UserCreate]):
    results = []
    for user in users:
        try:
            created_user = create_user_in_db(user)
            results.append({"status": "success", "data": created_user})
        except Exception as e:
            results.append({"status": "error", "error": str(e)})
    return results
```

### ç»Ÿä¸€å“åº”æ ¼å¼

```python
from pydantic import BaseModel
from typing import Generic, TypeVar, Optional, Any

T = TypeVar('T')

class ResponseModel(BaseModel, Generic[T]):
    success: bool
    message: str
    data: Optional[T] = None
    error: Optional[str] = None
    meta: Optional[dict] = None

class PaginatedResponse(BaseModel, Generic[T]):
    items: List[T]
    total: int
    page: int
    size: int
    pages: int

# ä½¿ç”¨ç¤ºä¾‹
@app.get("/users", response_model=PaginatedResponse[User])
async def get_users(page: int = 1, size: int = 10):
    users, total = get_users_paginated(page, size)
    return PaginatedResponse(
        items=users,
        total=total,
        page=page,
        size=size,
        pages=(total + size - 1) // size
    )

@app.get("/users/{user_id}", response_model=ResponseModel[User])
async def get_user(user_id: int):
    try:
        user = get_user_by_id(user_id)
        if not user:
            return ResponseModel(
                success=False,
                message="User not found",
                error="USER_NOT_FOUND"
            )
        return ResponseModel(
            success=True,
            message="User retrieved successfully",
            data=user
        )
    except Exception as e:
        return ResponseModel(
            success=False,
            message="Internal server error",
            error=str(e)
        )
```

## ğŸ”„ API ç‰ˆæœ¬ç®¡ç†

### URL ç‰ˆæœ¬æ§åˆ¶

```python
from fastapi import APIRouter, FastAPI

app = FastAPI()

# v1 ç‰ˆæœ¬
v1_router = APIRouter(prefix="/api/v1", tags=["v1"])

@v1_router.get("/users")
async def get_users_v1():
    return {"version": "v1", "users": []}

# v2 ç‰ˆæœ¬
v2_router = APIRouter(prefix="/api/v2", tags=["v2"])

@v2_router.get("/users")
async def get_users_v2():
    return {"version": "v2", "users": [], "metadata": {}}

# æ³¨å†Œè·¯ç”±
app.include_router(v1_router)
app.include_router(v2_router)
```

### å¤´éƒ¨ç‰ˆæœ¬æ§åˆ¶

```python
from fastapi import Header, HTTPException
from typing import Optional

def get_api_version(accept_version: Optional[str] = Header(None)):
    if accept_version is None:
        return "v1"  # é»˜è®¤ç‰ˆæœ¬
    return accept_version

@app.get("/users")
async def get_users(version: str = Depends(get_api_version)):
    if version == "v1":
        return get_users_v1()
    elif version == "v2":
        return get_users_v2()
    else:
        raise HTTPException(
            status_code=400,
            detail=f"Unsupported API version: {version}"
        )
```

### ç‰ˆæœ¬å…¼å®¹æ€§

```python
from enum import Enum
from datetime import datetime

class APIVersion(str, Enum):
    V1 = "v1"
    V2 = "v2"
    V3 = "v3"

class UserResponseV1(BaseModel):
    id: int
    username: str
    email: str

class UserResponseV2(BaseModel):
    id: int
    username: str
    email: str
    created_at: datetime
    updated_at: Optional[datetime]

class UserResponseV3(BaseModel):
    id: int
    username: str
    email: str
    profile: dict
    settings: dict

def get_user_response(version: APIVersion, user: User):
    if version == APIVersion.V1:
        return UserResponseV1(
            id=user.id,
            username=user.username,
            email=user.email
        )
    elif version == APIVersion.V2:
        return UserResponseV2(
            id=user.id,
            username=user.username,
            email=user.email,
            created_at=user.created_at,
            updated_at=user.updated_at
        )
    elif version == APIVersion.V3:
        return UserResponseV3(
            id=user.id,
            username=user.username,
            email=user.email,
            profile=user.profile,
            settings=user.settings
        )
```

## ğŸ›¡ï¸ é”™è¯¯å¤„ç†

### å…¨å±€å¼‚å¸¸å¤„ç†

```python
from fastapi import FastAPI, Request
from fastapi.responses import JSONResponse
from fastapi.exceptions import RequestValidationError
from starlette.exceptions import HTTPException as StarletteHTTPException
import logging

app = FastAPI()

# è‡ªå®šä¹‰å¼‚å¸¸
class CustomException(Exception):
    def __init__(self, message: str, error_code: str, status_code: int = 400):
        self.message = message
        self.error_code = error_code
        self.status_code = status_code

# å…¨å±€å¼‚å¸¸å¤„ç†å™¨
@app.exception_handler(CustomException)
async def custom_exception_handler(request: Request, exc: CustomException):
    return JSONResponse(
        status_code=exc.status_code,
        content={
            "success": False,
            "message": exc.message,
            "error_code": exc.error_code,
            "timestamp": datetime.utcnow().isoformat()
        }
    )

@app.exception_handler(StarletteHTTPException)
async def http_exception_handler(request: Request, exc: StarletteHTTPException):
    return JSONResponse(
        status_code=exc.status_code,
        content={
            "success": False,
            "message": exc.detail,
            "error_code": f"HTTP_{exc.status_code}",
            "timestamp": datetime.utcnow().isoformat()
        }
    )

@app.exception_handler(RequestValidationError)
async def validation_exception_handler(request: Request, exc: RequestValidationError):
    return JSONResponse(
        status_code=422,
        content={
            "success": False,
            "message": "Validation error",
            "error_code": "VALIDATION_ERROR",
            "details": exc.errors(),
            "timestamp": datetime.utcnow().isoformat()
        }
    )

@app.exception_handler(Exception)
async def general_exception_handler(request: Request, exc: Exception):
    logging.error(f"Unhandled exception: {str(exc)}", exc_info=True)
    return JSONResponse(
        status_code=500,
        content={
            "success": False,
            "message": "Internal server error",
            "error_code": "INTERNAL_ERROR",
            "timestamp": datetime.utcnow().isoformat()
        }
    )
```

### ä¸šåŠ¡å¼‚å¸¸

```python
class UserNotFoundException(CustomException):
    def __init__(self, user_id: int):
        super().__init__(
            message=f"User with id {user_id} not found",
            error_code="USER_NOT_FOUND",
            status_code=404
        )

class UserAlreadyExistsException(CustomException):
    def __init__(self, username: str):
        super().__init__(
            message=f"User with username {username} already exists",
            error_code="USER_ALREADY_EXISTS",
            status_code=409
        )

class InsufficientPermissionsException(CustomException):
    def __init__(self, action: str):
        super().__init__(
            message=f"Insufficient permissions for {action}",
            error_code="INSUFFICIENT_PERMISSIONS",
            status_code=403
        )

# ä½¿ç”¨ç¤ºä¾‹
@app.get("/users/{user_id}")
async def get_user(user_id: int):
    user = get_user_by_id(user_id)
    if not user:
        raise UserNotFoundException(user_id)
    return user

@app.post("/users")
async def create_user(user: UserCreate):
    existing_user = get_user_by_username(user.username)
    if existing_user:
        raise UserAlreadyExistsException(user.username)
    return create_user_in_db(user)
```

## ğŸ“ API æ–‡æ¡£ç”Ÿæˆ

### OpenAPI é…ç½®

```python
from fastapi import FastAPI
from fastapi.openapi.utils import get_openapi

app = FastAPI(
    title="User Management API",
    description="A comprehensive API for user management",
    version="1.0.0",
    contact={
        "name": "API Support",
        "email": "support@example.com",
    },
    license_info={
        "name": "MIT",
        "url": "https://opensource.org/licenses/MIT",
    },
)

def custom_openapi():
    if app.openapi_schema:
        return app.openapi_schema
    
    openapi_schema = get_openapi(
        title="User Management API",
        version="1.0.0",
        description="A comprehensive API for user management",
        routes=app.routes,
    )
    
    # è‡ªå®šä¹‰å®‰å…¨æ–¹æ¡ˆ
    openapi_schema["components"]["securitySchemes"] = {
        "BearerAuth": {
            "type": "http",
            "scheme": "bearer",
            "bearerFormat": "JWT",
        }
    }
    
    # å…¨å±€å®‰å…¨è¦æ±‚
    openapi_schema["security"] = [{"BearerAuth": []}]
    
    app.openapi_schema = openapi_schema
    return app.openapi_schema

app.openapi = custom_openapi
```

### è¯¦ç»†çš„ API æ–‡æ¡£

```python
from fastapi import FastAPI, Path, Query, Body, Depends
from typing import List, Optional

app = FastAPI()

@app.get(
    "/users",
    response_model=List[User],
    summary="Get all users",
    description="Retrieve a list of all users with optional filtering and pagination",
    response_description="List of users",
    tags=["Users"]
)
async def get_users(
    page: int = Query(1, ge=1, description="Page number"),
    size: int = Query(10, ge=1, le=100, description="Page size"),
    role: Optional[str] = Query(None, description="Filter by user role"),
    active: Optional[bool] = Query(None, description="Filter by active status")
):
    """
    Get all users with pagination and filtering.
    
    - **page**: Page number (minimum 1)
    - **size**: Number of items per page (1-100)
    - **role**: Filter users by role
    - **active**: Filter users by active status
    """
    return get_users_paginated(page, size, role, active)

@app.post(
    "/users",
    response_model=User,
    status_code=201,
    summary="Create a new user",
    description="Create a new user with the provided information",
    response_description="Created user",
    tags=["Users"]
)
async def create_user(
    user: UserCreate = Body(..., description="User data to create")
):
    """
    Create a new user.
    
    - **user**: User data including username, email, and password
    """
    return create_user_in_db(user)

@app.get(
    "/users/{user_id}",
    response_model=User,
    summary="Get user by ID",
    description="Retrieve a specific user by their ID",
    response_description="User information",
    tags=["Users"]
)
async def get_user(
    user_id: int = Path(..., gt=0, description="User ID")
):
    """
    Get a specific user by ID.
    
    - **user_id**: The ID of the user to retrieve (must be positive)
    """
    user = get_user_by_id(user_id)
    if not user:
        raise UserNotFoundException(user_id)
    return user
```

## ğŸ” å®‰å…¨è®¾è®¡

### è®¤è¯å’Œæˆæƒ

```python
from fastapi import Depends, HTTPException, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from jose import JWTError, jwt
from passlib.context import CryptContext

security = HTTPBearer()
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

# æƒé™æšä¸¾
class Permission(str, Enum):
    READ_USERS = "read_users"
    WRITE_USERS = "write_users"
    DELETE_USERS = "delete_users"
    ADMIN = "admin"

# è§’è‰²æƒé™æ˜ å°„
ROLE_PERMISSIONS = {
    "user": [Permission.READ_USERS],
    "moderator": [Permission.READ_USERS, Permission.WRITE_USERS],
    "admin": [Permission.READ_USERS, Permission.WRITE_USERS, Permission.DELETE_USERS, Permission.ADMIN]
}

def get_current_user(credentials: HTTPAuthorizationCredentials = Depends(security)):
    try:
        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[ALGORITHM])
        username: str = payload.get("sub")
        if username is None:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Could not validate credentials"
            )
        return username
    except JWTError:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Could not validate credentials"
        )

def require_permission(permission: Permission):
    def permission_dependency(current_user: str = Depends(get_current_user)):
        user = get_user_by_username(current_user)
        if not user:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="User not found"
            )
        
        user_permissions = ROLE_PERMISSIONS.get(user.role, [])
        if permission not in user_permissions:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="Insufficient permissions"
            )
        
        return current_user
    return permission_dependency

# ä½¿ç”¨æƒé™æ§åˆ¶
@app.get("/users", dependencies=[Depends(require_permission(Permission.READ_USERS))])
async def get_users():
    return get_all_users()

@app.post("/users", dependencies=[Depends(require_permission(Permission.WRITE_USERS))])
async def create_user(user: UserCreate):
    return create_user_in_db(user)

@app.delete("/users/{user_id}", dependencies=[Depends(require_permission(Permission.DELETE_USERS))])
async def delete_user(user_id: int):
    return delete_user_by_id(user_id)
```

### è¾“å…¥éªŒè¯

```python
from pydantic import BaseModel, validator, EmailStr, Field
from typing import Optional
import re

class UserCreate(BaseModel):
    username: str = Field(..., min_length=3, max_length=50, regex="^[a-zA-Z0-9_]+$")
    email: EmailStr
    password: str = Field(..., min_length=8)
    full_name: Optional[str] = Field(None, max_length=100)
    
    @validator('password')
    def validate_password(cls, v):
        if not re.search(r'[A-Z]', v):
            raise ValueError('Password must contain at least one uppercase letter')
        if not re.search(r'[a-z]', v):
            raise ValueError('Password must contain at least one lowercase letter')
        if not re.search(r'\d', v):
            raise ValueError('Password must contain at least one digit')
        if not re.search(r'[!@#$%^&*(),.?":{}|<>]', v):
            raise ValueError('Password must contain at least one special character')
        return v
    
    @validator('username')
    def validate_username(cls, v):
        if v.lower() in ['admin', 'root', 'system']:
            raise ValueError('Username is reserved')
        return v

class UserUpdate(BaseModel):
    username: Optional[str] = Field(None, min_length=3, max_length=50)
    email: Optional[EmailStr] = None
    full_name: Optional[str] = Field(None, max_length=100)
    is_active: Optional[bool] = None
```

## ğŸ“Š API ç›‘æ§å’Œæ—¥å¿—

### è¯·æ±‚æ—¥å¿—

```python
from fastapi import Request
import time
import logging
from datetime import datetime

# é…ç½®æ—¥å¿—
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

@app.middleware("http")
async def log_requests(request: Request, call_next):
    start_time = time.time()
    
    # è®°å½•è¯·æ±‚ä¿¡æ¯
    logger.info(f"Request: {request.method} {request.url}")
    logger.info(f"Headers: {dict(request.headers)}")
    
    # å¤„ç†è¯·æ±‚
    response = await call_next(request)
    
    # è®°å½•å“åº”ä¿¡æ¯
    process_time = time.time() - start_time
    logger.info(f"Response: {response.status_code} - {process_time:.4f}s")
    
    # æ·»åŠ å¤„ç†æ—¶é—´åˆ°å“åº”å¤´
    response.headers["X-Process-Time"] = str(process_time)
    
    return response
```

### API æŒ‡æ ‡

```python
from prometheus_client import Counter, Histogram, generate_latest
from fastapi import FastAPI
from fastapi.responses import Response

# å®šä¹‰æŒ‡æ ‡
REQUEST_COUNT = Counter('http_requests_total', 'Total HTTP requests', ['method', 'endpoint', 'status'])
REQUEST_DURATION = Histogram('http_request_duration_seconds', 'HTTP request duration')

app = FastAPI()

@app.middleware("http")
async def track_metrics(request: Request, call_next):
    start_time = time.time()
    
    response = await call_next(request)
    
    duration = time.time() - start_time
    REQUEST_DURATION.observe(duration)
    REQUEST_COUNT.labels(
        method=request.method,
        endpoint=request.url.path,
        status=response.status_code
    ).inc()
    
    return response

@app.get("/metrics")
async def get_metrics():
    return Response(generate_latest(), media_type="text/plain")
```

## ğŸ“š å­¦ä¹ èµ„æº

### å®˜æ–¹æ–‡æ¡£
- [REST API è®¾è®¡æŒ‡å—](https://restfulapi.net/)
- [OpenAPI è§„èŒƒ](https://swagger.io/specification/)
- [HTTP çŠ¶æ€ç ](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status)

### æ¨èé˜…è¯»
- [API è®¾è®¡æœ€ä½³å®è·µ](https://github.com/microsoft/api-guidelines)
- [RESTful Web Services](https://www.oreilly.com/library/view/restful-web-services/9780596529260/)

## ğŸ” çŸ¥è¯†æ£€æŸ¥

å®Œæˆæœ¬èŠ‚å­¦ä¹ åï¼Œè¯·æ£€æŸ¥æ˜¯å¦æŒæ¡ï¼š

- [ ] ç†è§£ RESTful API è®¾è®¡åŸåˆ™
- [ ] æŒæ¡ HTTP æ–¹æ³•å’ŒçŠ¶æ€ç çš„æ­£ç¡®ä½¿ç”¨
- [ ] èƒ½å¤Ÿè®¾è®¡ç»Ÿä¸€çš„å“åº”æ ¼å¼
- [ ] ç†è§£ API ç‰ˆæœ¬ç®¡ç†ç­–ç•¥
- [ ] æŒæ¡é”™è¯¯å¤„ç†å’Œå¼‚å¸¸ç®¡ç†
- [ ] å­¦ä¼šç”Ÿæˆå’Œç»´æŠ¤ API æ–‡æ¡£
- [ ] ç†è§£ API å®‰å…¨è®¾è®¡åŸåˆ™
- [ ] æŒæ¡ API ç›‘æ§å’Œæ—¥å¿—è®°å½•

---

**ä¸Šä¸€èŠ‚**ï¼š[2.2 æ•°æ®åº“æ“ä½œ](2.2-database.md) | **ä¸‹ä¸€èŠ‚**ï¼š[2.4 è®¤è¯ä¸å®‰å…¨](2.4-authentication.md) 