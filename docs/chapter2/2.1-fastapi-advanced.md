# 2.1 FastAPI è¿›é˜¶

## ğŸ“– æ¦‚è¿°

æœ¬ç« å°†æ·±å…¥å­¦ä¹  FastAPI çš„é«˜çº§ç‰¹æ€§ï¼ŒåŒ…æ‹¬ä¾èµ–æ³¨å…¥ç³»ç»Ÿã€ä¸­é—´ä»¶ã€å¼‚å¸¸å¤„ç†ã€åå°ä»»åŠ¡ã€WebSocket ç­‰ï¼Œå¸®åŠ©æ‚¨æ„å»ºæ›´å¼ºå¤§å’Œçµæ´»çš„ Web åº”ç”¨ã€‚

## ğŸ”§ ä¾èµ–æ³¨å…¥ç³»ç»Ÿ

### ä¾èµ–æ³¨å…¥åŸºç¡€

FastAPI çš„ä¾èµ–æ³¨å…¥ç³»ç»Ÿæ˜¯å…¶æ ¸å¿ƒç‰¹æ€§ä¹‹ä¸€ï¼Œå®ƒå¯ä»¥å¸®åŠ©æ‚¨ï¼š
- å…±äº«ä»£ç é€»è¾‘
- å¤ç”¨æ•°æ®åº“è¿æ¥
- å¤„ç†è®¤è¯å’Œæˆæƒ
- ç®¡ç†é…ç½®

### åŸºæœ¬ä¾èµ–æ³¨å…¥

```python
from fastapi import Depends, FastAPI
from typing import Optional

app = FastAPI()

# ç®€å•çš„ä¾èµ–å‡½æ•°
def get_db():
    db = Database()
    try:
        yield db
    finally:
        db.close()

# ä½¿ç”¨ä¾èµ–
@app.get("/users")
def read_users(db: Database = Depends(get_db)):
    users = db.get_users()
    return users
```

### å¸¦å‚æ•°çš„ä¾èµ–

```python
from fastapi import Depends, FastAPI, HTTPException, status
from typing import Optional

app = FastAPI()

# å¸¦å‚æ•°çš„ä¾èµ–å‡½æ•°
def get_user_by_id(user_id: int, db: Database = Depends(get_db)):
    user = db.get_user(user_id)
    if user is None:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User not found"
        )
    return user

# ä½¿ç”¨å¸¦å‚æ•°çš„ä¾èµ–
@app.get("/users/{user_id}")
def read_user(user: User = Depends(get_user_by_id)):
    return user
```

### ç±»ä¾èµ–

```python
from fastapi import Depends, FastAPI
from typing import Optional

app = FastAPI()

class UserService:
    def __init__(self, db: Database = Depends(get_db)):
        self.db = db
    
    def get_user(self, user_id: int):
        return self.db.get_user(user_id)
    
    def create_user(self, user_data: UserCreate):
        return self.db.create_user(user_data)

# ä½¿ç”¨ç±»ä¾èµ–
@app.get("/users/{user_id}")
def read_user(
    user_service: UserService = Depends(),
    user_id: int = Path(...)
):
    return user_service.get_user(user_id)
```

### ç¼“å­˜ä¾èµ–

```python
from fastapi import Depends, FastAPI
from functools import lru_cache

app = FastAPI()

@lru_cache()
def get_settings():
    return Settings()

@app.get("/info")
def read_info(settings: Settings = Depends(get_settings)):
    return {"app_name": settings.app_name}
```

## ğŸ›¡ï¸ ä¸­é—´ä»¶

### ä¸­é—´ä»¶åŸºç¡€

ä¸­é—´ä»¶æ˜¯åœ¨è¯·æ±‚å’Œå“åº”ä¹‹é—´æ‰§è¡Œçš„å‡½æ•°ï¼Œå¯ä»¥ç”¨äºï¼š
- æ—¥å¿—è®°å½•
- è®¤è¯æ£€æŸ¥
- è¯·æ±‚è®¡æ—¶
- CORS å¤„ç†
- é”™è¯¯å¤„ç†

### è‡ªå®šä¹‰ä¸­é—´ä»¶

```python
from fastapi import FastAPI, Request
import time
import logging

app = FastAPI()

# è¯·æ±‚è®¡æ—¶ä¸­é—´ä»¶
@app.middleware("http")
async def add_process_time_header(request: Request, call_next):
    start_time = time.time()
    response = await call_next(request)
    process_time = time.time() - start_time
    response.headers["X-Process-Time"] = str(process_time)
    return response

# æ—¥å¿—ä¸­é—´ä»¶
@app.middleware("http")
async def log_requests(request: Request, call_next):
    logging.info(f"Request: {request.method} {request.url}")
    response = await call_next(request)
    logging.info(f"Response: {response.status_code}")
    return response

# è®¤è¯ä¸­é—´ä»¶
@app.middleware("http")
async def auth_middleware(request: Request, call_next):
    # æ£€æŸ¥è®¤è¯å¤´
    auth_header = request.headers.get("Authorization")
    if not auth_header:
        return JSONResponse(
            status_code=401,
            content={"detail": "Missing authorization header"}
        )
    
    response = await call_next(request)
    return response
```

### é”™è¯¯å¤„ç†ä¸­é—´ä»¶

```python
from fastapi import FastAPI, Request
from fastapi.responses import JSONResponse
import logging

app = FastAPI()

@app.middleware("http")
async def error_handling_middleware(request: Request, call_next):
    try:
        response = await call_next(request)
        return response
    except Exception as e:
        logging.error(f"Unhandled error: {str(e)}")
        return JSONResponse(
            status_code=500,
            content={"detail": "Internal server error"}
        )
```

## âš¡ åå°ä»»åŠ¡

### åå°ä»»åŠ¡åŸºç¡€

FastAPI æ”¯æŒåå°ä»»åŠ¡ï¼Œå¯ä»¥åœ¨å“åº”è¿”å›åç»§ç»­æ‰§è¡Œé•¿æ—¶é—´è¿è¡Œçš„æ“ä½œã€‚

### åŸºæœ¬åå°ä»»åŠ¡

```python
from fastapi import FastAPI, BackgroundTasks
from typing import List

app = FastAPI()

def write_log(message: str):
    with open("log.txt", "a") as f:
        f.write(f"{message}\n")

@app.post("/send-notification/")
async def send_notification(
    email: str, 
    background_tasks: BackgroundTasks
):
    background_tasks.add_task(write_log, f"Notification sent to {email}")
    return {"message": "Notification sent in the background"}

# å¤šä¸ªåå°ä»»åŠ¡
@app.post("/process-data/")
async def process_data(
    data: List[str],
    background_tasks: BackgroundTasks
):
    for item in data:
        background_tasks.add_task(process_item, item)
    return {"message": f"Processing {len(data)} items in background"}
```

### å¸¦å‚æ•°çš„åå°ä»»åŠ¡

```python
from fastapi import FastAPI, BackgroundTasks
from pydantic import BaseModel

app = FastAPI()

class EmailData(BaseModel):
    to: str
    subject: str
    body: str

def send_email(email_data: EmailData):
    # æ¨¡æ‹Ÿå‘é€é‚®ä»¶
    print(f"Sending email to {email_data.to}")
    print(f"Subject: {email_data.subject}")
    print(f"Body: {email_data.body}")

@app.post("/send-email/")
async def send_email_endpoint(
    email_data: EmailData,
    background_tasks: BackgroundTasks
):
    background_tasks.add_task(send_email, email_data)
    return {"message": "Email will be sent in background"}
```

## ğŸ”Œ WebSocket æ”¯æŒ

### WebSocket åŸºç¡€

FastAPI æä¾›äº†å®Œæ•´çš„ WebSocket æ”¯æŒï¼Œå¯ä»¥ç”¨äºå®æ—¶é€šä¿¡ã€‚

### åŸºæœ¬ WebSocket

```python
from fastapi import FastAPI, WebSocket, WebSocketDisconnect
from typing import List

app = FastAPI()

# è¿æ¥ç®¡ç†å™¨
class ConnectionManager:
    def __init__(self):
        self.active_connections: List[WebSocket] = []

    async def connect(self, websocket: WebSocket):
        await websocket.accept()
        self.active_connections.append(websocket)

    def disconnect(self, websocket: WebSocket):
        self.active_connections.remove(websocket)

    async def send_personal_message(self, message: str, websocket: WebSocket):
        await websocket.send_text(message)

    async def broadcast(self, message: str):
        for connection in self.active_connections:
            await connection.send_text(message)

manager = ConnectionManager()

@app.websocket("/ws/{client_id}")
async def websocket_endpoint(websocket: WebSocket, client_id: int):
    await manager.connect(websocket)
    try:
        while True:
            data = await websocket.receive_text()
            await manager.send_personal_message(f"You wrote: {data}", websocket)
            await manager.broadcast(f"Client #{client_id} says: {data}")
    except WebSocketDisconnect:
        manager.disconnect(websocket)
        await manager.broadcast(f"Client #{client_id} left the chat")
```

### èŠå¤©å®¤åº”ç”¨

```python
from fastapi import FastAPI, WebSocket, WebSocketDisconnect
from typing import Dict, List
import json

app = FastAPI()

class ChatManager:
    def __init__(self):
        self.rooms: Dict[str, List[WebSocket]] = {}

    async def join_room(self, websocket: WebSocket, room: str):
        await websocket.accept()
        if room not in self.rooms:
            self.rooms[room] = []
        self.rooms[room].append(websocket)

    def leave_room(self, websocket: WebSocket, room: str):
        if room in self.rooms:
            self.rooms[room].remove(websocket)

    async def send_to_room(self, message: str, room: str):
        if room in self.rooms:
            for connection in self.rooms[room]:
                await connection.send_text(message)

chat_manager = ChatManager()

@app.websocket("/chat/{room}")
async def chat_endpoint(websocket: WebSocket, room: str):
    await chat_manager.join_room(websocket, room)
    try:
        while True:
            data = await websocket.receive_text()
            message_data = json.loads(data)
            await chat_manager.send_to_room(
                json.dumps({
                    "user": message_data["user"],
                    "message": message_data["message"]
                }),
                room
            )
    except WebSocketDisconnect:
        chat_manager.leave_room(websocket, room)
```

## ğŸ” é«˜çº§è®¤è¯

### JWT è®¤è¯

```python
from fastapi import FastAPI, Depends, HTTPException, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from jose import JWTError, jwt
from passlib.context import CryptContext
from datetime import datetime, timedelta
from typing import Optional

app = FastAPI()

# é…ç½®
SECRET_KEY = "your-secret-key"
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
security = HTTPBearer()

# å¯†ç å¤„ç†
def verify_password(plain_password, hashed_password):
    return pwd_context.verify(plain_password, hashed_password)

def get_password_hash(password):
    return pwd_context.hash(password)

# JWT å¤„ç†
def create_access_token(data: dict, expires_delta: Optional[timedelta] = None):
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(minutes=15)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt

def verify_token(credentials: HTTPAuthorizationCredentials = Depends(security)):
    try:
        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[ALGORITHM])
        username: str = payload.get("sub")
        if username is None:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Could not validate credentials"
            )
        return username
    except JWTError:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Could not validate credentials"
        )

# å—ä¿æŠ¤çš„è·¯ç”±
@app.get("/protected")
def read_protected_data(current_user: str = Depends(verify_token)):
    return {"message": "This is protected data", "user": current_user}
```

### OAuth2 è®¤è¯

```python
from fastapi import FastAPI, Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
from passlib.context import CryptContext
from datetime import datetime, timedelta
from typing import Optional

app = FastAPI()

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

# ç”¨æˆ·æ¨¡å‹
class User:
    def __init__(self, username: str, hashed_password: str):
        self.username = username
        self.hashed_password = hashed_password

# æ¨¡æ‹Ÿç”¨æˆ·æ•°æ®åº“
fake_users_db = {
    "johndoe": {
        "username": "johndoe",
        "hashed_password": pwd_context.hash("secret")
    }
}

def get_user(username: str):
    if username in fake_users_db:
        user_dict = fake_users_db[username]
        return User(**user_dict)

def authenticate_user(username: str, password: str):
    user = get_user(username)
    if not user:
        return False
    if not pwd_context.verify(password, user.hashed_password):
        return False
    return user

@app.post("/token")
async def login(form_data: OAuth2PasswordRequestForm = Depends()):
    user = authenticate_user(form_data.username, form_data.password)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect username or password",
            headers={"WWW-Authenticate": "Bearer"},
        )
    access_token = create_access_token(data={"sub": user.username})
    return {"access_token": access_token, "token_type": "bearer"}

@app.get("/users/me")
async def read_users_me(current_user: User = Depends(get_current_user)):
    return current_user
```

## ğŸ“Š æ•°æ®éªŒè¯å’Œåºåˆ—åŒ–

### é«˜çº§ Pydantic æ¨¡å‹

```python
from pydantic import BaseModel, Field, validator, EmailStr
from typing import List, Optional
from datetime import datetime
from enum import Enum

class UserRole(str, Enum):
    ADMIN = "admin"
    USER = "user"
    MODERATOR = "moderator"

class UserBase(BaseModel):
    username: str = Field(..., min_length=3, max_length=50, regex="^[a-zA-Z0-9_]+$")
    email: EmailStr
    full_name: Optional[str] = None
    age: Optional[int] = Field(None, ge=0, le=150)

class UserCreate(UserBase):
    password: str = Field(..., min_length=8)
    
    @validator('password')
    def validate_password(cls, v):
        if not any(c.isupper() for c in v):
            raise ValueError('Password must contain at least one uppercase letter')
        if not any(c.islower() for c in v):
            raise ValueError('Password must contain at least one lowercase letter')
        if not any(c.isdigit() for c in v):
            raise ValueError('Password must contain at least one digit')
        return v

class User(UserBase):
    id: int
    role: UserRole = UserRole.USER
    is_active: bool = True
    created_at: datetime
    updated_at: Optional[datetime] = None

    class Config:
        from_attributes = True
        json_encoders = {
            datetime: lambda v: v.isoformat()
        }
```

### è‡ªå®šä¹‰éªŒè¯å™¨

```python
from pydantic import BaseModel, validator
from typing import List

class Product(BaseModel):
    name: str
    price: float
    categories: List[str]
    
    @validator('price')
    def validate_price(cls, v):
        if v <= 0:
            raise ValueError('Price must be positive')
        return round(v, 2)
    
    @validator('categories')
    def validate_categories(cls, v):
        if len(v) == 0:
            raise ValueError('At least one category is required')
        if len(v) > 5:
            raise ValueError('Maximum 5 categories allowed')
        return v
    
    @validator('name')
    def validate_name(cls, v):
        if len(v.strip()) == 0:
            raise ValueError('Name cannot be empty')
        return v.strip()
```

## ğŸš€ æ€§èƒ½ä¼˜åŒ–

### å¼‚æ­¥æ•°æ®åº“æ“ä½œ

```python
from fastapi import FastAPI, Depends
from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine
from sqlalchemy.orm import sessionmaker
from typing import List

app = FastAPI()

# å¼‚æ­¥æ•°æ®åº“å¼•æ“
DATABASE_URL = "postgresql+asyncpg://user:password@localhost/dbname"
engine = create_async_engine(DATABASE_URL)
AsyncSessionLocal = sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)

async def get_db():
    async with AsyncSessionLocal() as session:
        yield session

@app.get("/users")
async def get_users(db: AsyncSession = Depends(get_db)):
    result = await db.execute("SELECT * FROM users")
    users = result.fetchall()
    return users
```

### ç¼“å­˜ç­–ç•¥

```python
from fastapi import FastAPI, Depends
from fastapi_cache import FastAPICache
from fastapi_cache.backends.redis import RedisBackend
from fastapi_cache.decorator import cache
import redis

app = FastAPI()

@app.on_event("startup")
async def startup():
    redis = redis.from_url("redis://localhost", encoding="utf8", decode_responses=True)
    FastAPICache.init(RedisBackend(redis), prefix="fastapi-cache")

@app.get("/users/{user_id}")
@cache(expire=60)  # ç¼“å­˜60ç§’
async def get_user(user_id: int):
    # æ¨¡æ‹Ÿæ•°æ®åº“æŸ¥è¯¢
    return {"user_id": user_id, "name": "John Doe"}
```

## ğŸ“š å­¦ä¹ èµ„æº

### å®˜æ–¹æ–‡æ¡£
- [FastAPI ä¾èµ–æ³¨å…¥](https://fastapi.tiangolo.com/tutorial/dependencies/)
- [FastAPI ä¸­é—´ä»¶](https://fastapi.tiangolo.com/tutorial/middleware/)
- [FastAPI WebSocket](https://fastapi.tiangolo.com/advanced/websockets/)

### æ¨èé˜…è¯»
- [FastAPI æœ€ä½³å®è·µ](https://fastapi.tiangolo.com/tutorial/best-practices/)
- [å¼‚æ­¥ç¼–ç¨‹æŒ‡å—](https://docs.python.org/3/library/asyncio.html)

## ğŸ” çŸ¥è¯†æ£€æŸ¥

å®Œæˆæœ¬èŠ‚å­¦ä¹ åï¼Œè¯·æ£€æŸ¥æ˜¯å¦æŒæ¡ï¼š

- [ ] ç†è§£ä¾èµ–æ³¨å…¥ç³»ç»Ÿçš„å·¥ä½œåŸç†
- [ ] èƒ½å¤Ÿåˆ›å»ºå’Œä½¿ç”¨è‡ªå®šä¹‰ä¸­é—´ä»¶
- [ ] æŒæ¡åå°ä»»åŠ¡çš„å®ç°æ–¹å¼
- [ ] èƒ½å¤Ÿå®ç° WebSocket å®æ—¶é€šä¿¡
- [ ] ç†è§£é«˜çº§è®¤è¯æœºåˆ¶
- [ ] æŒæ¡æ•°æ®éªŒè¯å’Œåºåˆ—åŒ–æŠ€å·§
- [ ] å­¦ä¼šæ€§èƒ½ä¼˜åŒ–æ–¹æ³•

---

**ä¸Šä¸€èŠ‚**ï¼š[1.4 å®è·µé¡¹ç›®](chapter1/1.4-practice-project.md) | **ä¸‹ä¸€èŠ‚**ï¼š[2.2 æ•°æ®åº“æ“ä½œ](2.2-database.md) 