# 2.2 æ•°æ®åº“æ“ä½œ

## ğŸ“– æ¦‚è¿°

æœ¬ç« å°†æ·±å…¥å­¦ä¹ æ•°æ®åº“æ“ä½œï¼ŒåŒ…æ‹¬ SQLAlchemy ORM çš„ä½¿ç”¨ã€æ•°æ®åº“è®¾è®¡ã€æŸ¥è¯¢ä¼˜åŒ–ã€äº‹åŠ¡å¤„ç†ç­‰ï¼Œå¸®åŠ©æ‚¨æ„å»ºé«˜æ•ˆçš„æ•°æ®æŒä¹…åŒ–å±‚ã€‚

## ğŸ—„ï¸ æ•°æ®åº“åŸºç¡€

### æ•°æ®åº“ç±»å‹é€‰æ‹©

| æ•°æ®åº“ç±»å‹ | ç‰¹ç‚¹ | é€‚ç”¨åœºæ™¯ |
|------------|------|----------|
| **SQLite** | è½»é‡çº§ã€æ–‡ä»¶å‹ | å¼€å‘æµ‹è¯•ã€å°å‹åº”ç”¨ |
| **PostgreSQL** | åŠŸèƒ½å¼ºå¤§ã€ACID | ç”Ÿäº§ç¯å¢ƒã€å¤æ‚æŸ¥è¯¢ |
| **MySQL** | æµè¡Œã€æ˜“ç”¨ | Web åº”ç”¨ã€ä¸­ç­‰è§„æ¨¡ |
| **MongoDB** | æ–‡æ¡£å‹ã€çµæ´» | å¤§æ•°æ®ã€éç»“æ„åŒ–æ•°æ® |

### SQLAlchemy ç®€ä»‹

SQLAlchemy æ˜¯ Python æœ€æµè¡Œçš„ ORMï¼ˆå¯¹è±¡å…³ç³»æ˜ å°„ï¼‰åº“ï¼Œæä¾›äº†ï¼š
- æ•°æ®åº“æŠ½è±¡å±‚
- ORM æ˜ å°„
- æŸ¥è¯¢æ„å»ºå™¨
- äº‹åŠ¡ç®¡ç†
- è¿æ¥æ± 

## ğŸ—ï¸ æ•°æ®åº“é…ç½®

### åŸºæœ¬é…ç½®

```python
from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from sqlalchemy.pool import StaticPool

# æ•°æ®åº“ URL
DATABASE_URL = "sqlite:///./app.db"

# åˆ›å»ºå¼•æ“
engine = create_engine(
    DATABASE_URL,
    connect_args={"check_same_thread": False},  # SQLite ä¸“ç”¨
    poolclass=StaticPool,  # è¿æ¥æ± ç±»å‹
    echo=True  # æ˜¾ç¤º SQL è¯­å¥
)

# åˆ›å»ºä¼šè¯å·¥å‚
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

# åˆ›å»ºåŸºç¡€ç±»
Base = declarative_base()

# ä¾èµ–æ³¨å…¥
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()
```

### ç¯å¢ƒé…ç½®

```python
from pydantic import BaseSettings

class Settings(BaseSettings):
    database_url: str = "sqlite:///./app.db"
    database_echo: bool = False
    
    class Config:
        env_file = ".env"

settings = Settings()

engine = create_engine(
    settings.database_url,
    echo=settings.database_echo
)
```

## ğŸ“Š æ•°æ®æ¨¡å‹è®¾è®¡

### åŸºæœ¬æ¨¡å‹

```python
from sqlalchemy import Column, Integer, String, Boolean, DateTime, Text, ForeignKey
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from database import Base
from datetime import datetime

class User(Base):
    __tablename__ = "users"
    
    id = Column(Integer, primary_key=True, index=True)
    username = Column(String(50), unique=True, index=True, nullable=False)
    email = Column(String(100), unique=True, index=True, nullable=False)
    hashed_password = Column(String(255), nullable=False)
    full_name = Column(String(100))
    is_active = Column(Boolean, default=True)
    is_superuser = Column(Boolean, default=False)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())
    
    # å…³ç³»
    posts = relationship("Post", back_populates="author")
    comments = relationship("Comment", back_populates="author")

class Post(Base):
    __tablename__ = "posts"
    
    id = Column(Integer, primary_key=True, index=True)
    title = Column(String(200), nullable=False)
    content = Column(Text)
    published = Column(Boolean, default=False)
    author_id = Column(Integer, ForeignKey("users.id"))
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())
    
    # å…³ç³»
    author = relationship("User", back_populates="posts")
    comments = relationship("Comment", back_populates="post")

class Comment(Base):
    __tablename__ = "comments"
    
    id = Column(Integer, primary_key=True, index=True)
    content = Column(Text, nullable=False)
    author_id = Column(Integer, ForeignKey("users.id"))
    post_id = Column(Integer, ForeignKey("posts.id"))
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    
    # å…³ç³»
    author = relationship("User", back_populates="comments")
    post = relationship("Post", back_populates="comments")
```

### é«˜çº§æ¨¡å‹ç‰¹æ€§

```python
from sqlalchemy import Column, Integer, String, Enum, CheckConstraint
from sqlalchemy.ext.hybrid import hybrid_property
import enum

class UserRole(enum.Enum):
    ADMIN = "admin"
    MODERATOR = "moderator"
    USER = "user"

class User(Base):
    __tablename__ = "users"
    
    id = Column(Integer, primary_key=True)
    username = Column(String(50), unique=True, nullable=False)
    email = Column(String(100), unique=True, nullable=False)
    role = Column(Enum(UserRole), default=UserRole.USER)
    age = Column(Integer)
    
    # æ£€æŸ¥çº¦æŸ
    __table_args__ = (
        CheckConstraint('age >= 0', name='check_age_positive'),
        CheckConstraint('age <= 150', name='check_age_reasonable'),
    )
    
    # æ··åˆå±æ€§
    @hybrid_property
    def is_adult(self):
        return self.age >= 18 if self.age else False
    
    @hybrid_property
    def display_name(self):
        return self.username or self.email.split('@')[0]
```

## ğŸ” æŸ¥è¯¢æ“ä½œ

### åŸºæœ¬æŸ¥è¯¢

```python
from sqlalchemy.orm import Session
from sqlalchemy import select, and_, or_, not_

# è·å–æ‰€æœ‰ç”¨æˆ·
def get_all_users(db: Session):
    return db.query(User).all()

# æ ¹æ® ID è·å–ç”¨æˆ·
def get_user_by_id(db: Session, user_id: int):
    return db.query(User).filter(User.id == user_id).first()

# æ ¹æ®ç”¨æˆ·åè·å–ç”¨æˆ·
def get_user_by_username(db: Session, username: str):
    return db.query(User).filter(User.username == username).first()

# è·å–æ´»è·ƒç”¨æˆ·
def get_active_users(db: Session):
    return db.query(User).filter(User.is_active == True).all()

# å¤æ‚æŸ¥è¯¢
def get_users_by_criteria(db: Session, min_age: int = None, role: UserRole = None):
    query = db.query(User)
    
    if min_age is not None:
        query = query.filter(User.age >= min_age)
    
    if role is not None:
        query = query.filter(User.role == role)
    
    return query.all()
```

### é«˜çº§æŸ¥è¯¢

```python
from sqlalchemy import func, desc, asc
from sqlalchemy.orm import joinedload, selectinload

# èšåˆæŸ¥è¯¢
def get_user_stats(db: Session):
    return db.query(
        func.count(User.id).label('total_users'),
        func.avg(User.age).label('avg_age'),
        func.max(User.created_at).label('latest_user')
    ).first()

# åˆ†ç»„æŸ¥è¯¢
def get_users_by_role(db: Session):
    return db.query(
        User.role,
        func.count(User.id).label('count')
    ).group_by(User.role).all()

# æ’åºæŸ¥è¯¢
def get_users_sorted(db: Session, sort_by: str = 'created_at', order: str = 'desc'):
    query = db.query(User)
    
    if sort_by == 'username':
        query = query.order_by(desc(User.username) if order == 'desc' else asc(User.username))
    elif sort_by == 'created_at':
        query = query.order_by(desc(User.created_at) if order == 'desc' else asc(User.created_at))
    
    return query.all()

# åˆ†é¡µæŸ¥è¯¢
def get_users_paginated(db: Session, skip: int = 0, limit: int = 10):
    return db.query(User).offset(skip).limit(limit).all()

# é¢„åŠ è½½å…³è”æ•°æ®
def get_posts_with_author(db: Session):
    return db.query(Post).options(joinedload(Post.author)).all()

def get_users_with_posts(db: Session):
    return db.query(User).options(selectinload(User.posts)).all()
```

### åŸç”Ÿ SQL æŸ¥è¯¢

```python
from sqlalchemy import text

# åŸç”Ÿ SQL æŸ¥è¯¢
def get_user_stats_raw_sql(db: Session):
    result = db.execute(text("""
        SELECT 
            COUNT(*) as total_users,
            AVG(age) as avg_age,
            MAX(created_at) as latest_user
        FROM users
        WHERE is_active = :is_active
    """), {"is_active": True})
    
    return result.first()

# å¤æ‚åŸç”ŸæŸ¥è¯¢
def search_users_raw_sql(db: Session, search_term: str):
    result = db.execute(text("""
        SELECT u.*, COUNT(p.id) as post_count
        FROM users u
        LEFT JOIN posts p ON u.id = p.author_id
        WHERE u.username LIKE :search OR u.email LIKE :search
        GROUP BY u.id
        ORDER BY post_count DESC
    """), {"search": f"%{search_term}%"})
    
    return result.fetchall()
```

## âœï¸ æ•°æ®æ“ä½œ

### åˆ›å»ºæ“ä½œ

```python
from sqlalchemy.orm import Session
from pydantic import BaseModel

class UserCreate(BaseModel):
    username: str
    email: str
    password: str
    full_name: str = None

def create_user(db: Session, user_data: UserCreate):
    # å¯†ç å“ˆå¸Œå¤„ç†
    hashed_password = get_password_hash(user_data.password)
    
    # åˆ›å»ºç”¨æˆ·å¯¹è±¡
    db_user = User(
        username=user_data.username,
        email=user_data.email,
        hashed_password=hashed_password,
        full_name=user_data.full_name
    )
    
    # æ·»åŠ åˆ°æ•°æ®åº“
    db.add(db_user)
    db.commit()
    db.refresh(db_user)
    
    return db_user

# æ‰¹é‡åˆ›å»º
def create_users_batch(db: Session, users_data: List[UserCreate]):
    users = []
    for user_data in users_data:
        hashed_password = get_password_hash(user_data.password)
        user = User(
            username=user_data.username,
            email=user_data.email,
            hashed_password=hashed_password,
            full_name=user_data.full_name
        )
        users.append(user)
    
    db.add_all(users)
    db.commit()
    
    return users
```

### æ›´æ–°æ“ä½œ

```python
class UserUpdate(BaseModel):
    username: str = None
    email: str = None
    full_name: str = None
    is_active: bool = None

def update_user(db: Session, user_id: int, user_data: UserUpdate):
    # è·å–ç”¨æˆ·
    db_user = db.query(User).filter(User.id == user_id).first()
    if not db_user:
        return None
    
    # æ›´æ–°å­—æ®µ
    update_data = user_data.dict(exclude_unset=True)
    for field, value in update_data.items():
        setattr(db_user, field, value)
    
    # æäº¤æ›´æ”¹
    db.commit()
    db.refresh(db_user)
    
    return db_user

# æ‰¹é‡æ›´æ–°
def update_users_by_role(db: Session, role: UserRole, is_active: bool):
    db.query(User).filter(User.role == role).update(
        {"is_active": is_active},
        synchronize_session=False
    )
    db.commit()
```

### åˆ é™¤æ“ä½œ

```python
def delete_user(db: Session, user_id: int):
    db_user = db.query(User).filter(User.id == user_id).first()
    if not db_user:
        return False
    
    db.delete(db_user)
    db.commit()
    
    return True

# è½¯åˆ é™¤ï¼ˆæ ‡è®°åˆ é™¤ï¼‰
def soft_delete_user(db: Session, user_id: int):
    db_user = db.query(User).filter(User.id == user_id).first()
    if not db_user:
        return False
    
    db_user.is_active = False
    db.commit()
    
    return True

# æ‰¹é‡åˆ é™¤
def delete_inactive_users(db: Session):
    result = db.query(User).filter(User.is_active == False).delete()
    db.commit()
    return result
```

## ğŸ”„ äº‹åŠ¡å¤„ç†

### åŸºæœ¬äº‹åŠ¡

```python
from sqlalchemy.orm import Session
from sqlalchemy.exc import SQLAlchemyError

def create_user_with_profile(db: Session, user_data: UserCreate, profile_data: dict):
    try:
        # å¼€å§‹äº‹åŠ¡
        db.begin()
        
        # åˆ›å»ºç”¨æˆ·
        user = create_user(db, user_data)
        
        # åˆ›å»ºç”¨æˆ·èµ„æ–™
        profile = UserProfile(
            user_id=user.id,
            **profile_data
        )
        db.add(profile)
        
        # æäº¤äº‹åŠ¡
        db.commit()
        
        return user
    except SQLAlchemyError as e:
        # å›æ»šäº‹åŠ¡
        db.rollback()
        raise e

# ä½¿ç”¨ä¸Šä¸‹æ–‡ç®¡ç†å™¨
from contextlib import contextmanager

@contextmanager
def transaction(db: Session):
    try:
        yield db
        db.commit()
    except Exception:
        db.rollback()
        raise

def safe_create_user(db: Session, user_data: UserCreate):
    with transaction(db):
        user = User(**user_data.dict())
        db.add(user)
        return user
```

### åµŒå¥—äº‹åŠ¡

```python
def complex_operation(db: Session):
    try:
        # å¤–å±‚äº‹åŠ¡
        db.begin()
        
        # åˆ›å»ºç”¨æˆ·
        user = create_user(db, user_data)
        
        try:
            # å†…å±‚äº‹åŠ¡
            db.begin()
            
            # åˆ›å»ºç”¨æˆ·ç»„
            group = create_group(db, group_data)
            
            # æ·»åŠ ç”¨æˆ·åˆ°ç»„
            user_group = UserGroup(user_id=user.id, group_id=group.id)
            db.add(user_group)
            
            # æäº¤å†…å±‚äº‹åŠ¡
            db.commit()
            
        except Exception as e:
            # å›æ»šå†…å±‚äº‹åŠ¡
            db.rollback()
            raise e
        
        # æäº¤å¤–å±‚äº‹åŠ¡
        db.commit()
        
    except Exception as e:
        # å›æ»šå¤–å±‚äº‹åŠ¡
        db.rollback()
        raise e
```

## ğŸš€ æ€§èƒ½ä¼˜åŒ–

### æŸ¥è¯¢ä¼˜åŒ–

```python
# ä½¿ç”¨ç´¢å¼•
def get_users_by_email_optimized(db: Session, email: str):
    # ç¡®ä¿ email å­—æ®µæœ‰ç´¢å¼•
    return db.query(User).filter(User.email == email).first()

# é¿å… N+1 æŸ¥è¯¢é—®é¢˜
def get_posts_with_authors_optimized(db: Session):
    # ä½¿ç”¨ joinedload é¢„åŠ è½½å…³è”æ•°æ®
    return db.query(Post).options(
        joinedload(Post.author),
        joinedload(Post.comments).joinedload(Comment.author)
    ).all()

# ä½¿ç”¨ selectinload è¿›è¡Œæ‰¹é‡åŠ è½½
def get_users_with_posts_optimized(db: Session):
    return db.query(User).options(
        selectinload(User.posts),
        selectinload(User.comments)
    ).all()

# åˆ†é¡µä¼˜åŒ–
def get_users_paginated_optimized(db: Session, page: int = 1, size: int = 20):
    offset = (page - 1) * size
    return db.query(User).offset(offset).limit(size).all()
```

### è¿æ¥æ± é…ç½®

```python
from sqlalchemy import create_engine
from sqlalchemy.pool import QueuePool

# é…ç½®è¿æ¥æ± 
engine = create_engine(
    DATABASE_URL,
    poolclass=QueuePool,
    pool_size=20,  # è¿æ¥æ± å¤§å°
    max_overflow=30,  # æœ€å¤§æº¢å‡ºè¿æ¥æ•°
    pool_pre_ping=True,  # è¿æ¥å‰æ£€æŸ¥
    pool_recycle=3600,  # è¿æ¥å›æ”¶æ—¶é—´ï¼ˆç§’ï¼‰
    echo=False
)
```

### ç¼“å­˜ç­–ç•¥

```python
from functools import lru_cache
import redis

# å†…å­˜ç¼“å­˜
@lru_cache(maxsize=128)
def get_user_by_id_cached(user_id: int):
    return get_user_by_id(db, user_id)

# Redis ç¼“å­˜
redis_client = redis.Redis(host='localhost', port=6379, db=0)

def get_user_with_redis_cache(db: Session, user_id: int):
    # å°è¯•ä»ç¼“å­˜è·å–
    cache_key = f"user:{user_id}"
    cached_user = redis_client.get(cache_key)
    
    if cached_user:
        return json.loads(cached_user)
    
    # ä»æ•°æ®åº“è·å–
    user = get_user_by_id(db, user_id)
    if user:
        # å­˜å…¥ç¼“å­˜
        redis_client.setex(cache_key, 3600, json.dumps(user.dict()))
    
    return user
```

## ğŸ“Š æ•°æ®åº“è¿ç§»

### Alembic é…ç½®

```python
# alembic.ini
[alembic]
script_location = alembic
sqlalchemy.url = sqlite:///./app.db

# env.py
from alembic import context
from sqlalchemy import engine_from_config, pool
from logging.config import fileConfig
from models import Base

config = context.config
fileConfig(config.config_file_name)
target_metadata = Base.metadata

def run_migrations_online():
    connectable = engine_from_config(
        config.get_section(config.config_ini_section),
        prefix="sqlalchemy.",
        poolclass=pool.NullPool,
    )

    with connectable.connect() as connection:
        context.configure(
            connection=connection,
            target_metadata=target_metadata
        )

        with context.begin_transaction():
            context.run_migrations()
```

### è¿ç§»è„šæœ¬

```python
# åˆ›å»ºè¿ç§»
# alembic revision --autogenerate -m "Add user table"

# è¿ç§»æ–‡ä»¶ç¤ºä¾‹
"""Add user table

Revision ID: 001
Revises: 
Create Date: 2023-01-01 12:00:00.000000

"""
from alembic import op
import sqlalchemy as sa

def upgrade():
    op.create_table(
        'users',
        sa.Column('id', sa.Integer(), nullable=False),
        sa.Column('username', sa.String(length=50), nullable=False),
        sa.Column('email', sa.String(length=100), nullable=False),
        sa.Column('hashed_password', sa.String(length=255), nullable=False),
        sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.text('now()')),
        sa.PrimaryKeyConstraint('id')
    )
    op.create_index(op.f('ix_users_email'), 'users', ['email'], unique=True)
    op.create_index(op.f('ix_users_username'), 'users', ['username'], unique=True)

def downgrade():
    op.drop_index(op.f('ix_users_username'), table_name='users')
    op.drop_index(op.f('ix_users_email'), table_name='users')
    op.drop_table('users')
```

## ğŸ“š å­¦ä¹ èµ„æº

### å®˜æ–¹æ–‡æ¡£
- [SQLAlchemy å®˜æ–¹æ–‡æ¡£](https://docs.sqlalchemy.org/)
- [Alembic è¿ç§»æ–‡æ¡£](https://alembic.sqlalchemy.org/)
- [PostgreSQL æ–‡æ¡£](https://www.postgresql.org/docs/)

### æ¨èé˜…è¯»
- [SQLAlchemy æœ€ä½³å®è·µ](https://docs.sqlalchemy.org/en/14/orm/best_practices.html)
- [æ•°æ®åº“è®¾è®¡åŸåˆ™](https://en.wikipedia.org/wiki/Database_design)

## ğŸ” çŸ¥è¯†æ£€æŸ¥

å®Œæˆæœ¬èŠ‚å­¦ä¹ åï¼Œè¯·æ£€æŸ¥æ˜¯å¦æŒæ¡ï¼š

- [ ] ç†è§£æ•°æ®åº“ç±»å‹å’Œé€‰æ‹©åŸåˆ™
- [ ] æŒæ¡ SQLAlchemy ORM çš„åŸºæœ¬ä½¿ç”¨
- [ ] èƒ½å¤Ÿè®¾è®¡åˆç†çš„æ•°æ®æ¨¡å‹
- [ ] æŒæ¡å„ç§æŸ¥è¯¢æ“ä½œå’Œä¼˜åŒ–æŠ€å·§
- [ ] ç†è§£äº‹åŠ¡å¤„ç†å’Œé”™è¯¯å¤„ç†
- [ ] å­¦ä¼šæ•°æ®åº“è¿ç§»å’Œç‰ˆæœ¬ç®¡ç†
- [ ] æŒæ¡æ€§èƒ½ä¼˜åŒ–å’Œç¼“å­˜ç­–ç•¥

---

**ä¸Šä¸€èŠ‚**ï¼š[2.1 FastAPI è¿›é˜¶](2.1-fastapi-advanced.md) | **ä¸‹ä¸€èŠ‚**ï¼š[2.3 API è®¾è®¡](2.3-api-design.md) 